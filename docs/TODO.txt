  LLAMA Known Issues and TODO
===============================

  Big Issues
--------------

ISSUE: Deletions in the writable representation require deletion vectors, which
makes it also difficult to use copy-on-delete

The writable representation currently implements deletions only using deletion
vectors, which is a problem because:
  a) Deletion vectors incur high performance overhead for analytics, even if the
     algorithm runs directly on the read-optimized graph representation
  b) Modifying deletion vectors does not work with persistence as that requires
     modifying already-written data
  c) It does not make sense to use copy-on-delete and deletion vectors at the
     same time, so the fact that the writable representation requires deletion
     vectors means that it is impossible for a normal user to take advantage of
     copy-on-delete (the building blocks are there, but not the total solution)

Potential solution:
  1) Implement a deletion bitmap just for the writable representation that
     lives outside of the CSR
  2) Modify the private edge_property_level_creation_callback class and the
     init_level_from_degrees() method of the CSR representation to take copying
     due to copy-in-delete into account when computing the lengths of the edge
     table and of the edge property arrays
  3) Modify the init_node() method on the CSR representation to actually copy on
     delete by taking the deletion bitmaps into account; modify the private
     class edge_property_level_creation_callback to copy the appropriate
     edge property values corresponding to the edges copied on delete


ISSUE: Variable-length properties

LLAMA currently supports only fixed-length 32-bit and 64-bit properties, but it
really should support variable-length properties as well, especially strings. It
currently supports strings for in-memory LLAMA only, but it should also work
with persistence and streaming.

Potential solution:
  1) Store the new property values and their lengths in the corresponding
     property data file (or a malloc-ed buffer when in memory) and store
     bit-packed location tuples of the form (chunk/buffer ID, byte offset) in
     the actual fixed-size property
  2) Create another property class or add another template argument to the
     current property classes to deal with variable properties; modify the
     operator[] to translate the location tuple to the corresponding pointer in
     the buffer (for data types other than string, this operator or some other
     method should also return the length)


ISSUE: Loading edge properties from persistent storage and their file format

LLAMA can currently write edge properties to persistent storage, but it cannot
yet read them back in when it opens the database. The problem seems to be in the
way they are stored in O(n^2) files, where n is the number of snapshots. This is
excessive and needs to be changed back to O(n) like everything else.


ISSUE: Fully-functional flatten (merging all snapshots)

Flattening the database is currently implemented just as one of the
"benchmarks," and it only supports dealing with out-edges. Flatten should be its
own function, and there should be ideally also a stand-alone tool that would run
it on an existing database. Flatten should be able to also process in-edges,
out-to-in and in-to-out edge ID translations, and vertex and edge properties.


ISSUE: Out-to-in and in-to-out edge ID translations

These edge ID translation properties are currently only generated by the FGF
loader and the writable representation checkpoint, I think. We should implement
such functionality to the other loaders as well but keep it optional, as this
takes a lot of memory and not everyone needs it.


ISSUE: Automatic loading of properties when opening the database

This currently requires the user to know the names and types of all stored
properties to open them.



  Smaller Issues
------------------

ISSUE: Error checking == abort()

If LLAMA encounters an error, it prints a message to stderr and calls abort().
While this might be fine in research code, it should be fixed before anyone else
tries to use it for real.


ISSUE: Global, shared LLAMA object

There is currently no global object that stores global LLAMA configuration, such
as the desired number of OpenMP threads. It would be also good to have such
object to store global things like free lists, or alternatively we can make free
lists to be private to the graph (this is probably a better idea).


ISSUE: SLOTH / streaming should be more abstracted

The streaming / sliding window implementation is currently partially shared
between ll_streaming.h and the benchmark tool. All relevant code should be in
ll_streaming.h, so that it is more easily reusable.


ISSUE: Inconsistent types for level (snapshot) numbers

The code uses int, unsigned, and size_t in different places. This is messy. We
should probably introduce level_t.


ISSUE: Renaming levels to snapshots, values to edge_table, begin to
vertex_table, node_t to vertex_t (and probably more)

It would be nice if the terminology in the code matched the paper.


ISSUE: The maximum number of vertices in the writable graph stroe is currently
hard-coded


ISSUE: Prune all half-finished and abandoned features.


ISSUE: Not all loaders support all features...


ISSUE: Sparse properties

Currently all properties allocate space for all vertices or edges in level 0,
which is too wasteful if not all of them will have an assigned value.


ISSUE: Mark nodes as deleted

There is currently no way to distinguish deleted nodes and nodes with no
(out-)edges.


ISSUE: There is currently not an easy way to determine the number of vertices
and edges in the database.



  Potentially Useful Features
-------------------------------

FEATURE: Loaders for more common formats, such as GraphML or adjacency lists

Especially adjacency lists would be quite useful.


FEATURE: 32-bit node IDs

This could save us potentially quite a bit of memory if we have < 2^32 vertices
and don't use deletion vectors.


FEATURE: Create memory-only and file-based LLAMA's alongside each other

You currently can create one or the other depending on the selected compile-time
settings.


FEATURE: Write-ahead log for the write-optimized store to guarantee durability


FEATURE: Real documentation

